---
title: "SamplR Summary Report"
fig.height: 4.5
fig.width: 7.5
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}

# devtools::install_github("ropenscilabs/ochRe")
# 
# remotes::install_github("ninoxconsulting/PEMr", build_vignettes = FALSE)
# remotes::install_github("ninoxconsulting/PEMprepr", build_vignettes = FALSE)
# remotes::install_github("ninoxconsulting/PEMsamplr", build_vignettes = FALSE)

# library(PEMr)
# library(PEMprepr)
# require(PEMsamplr)
require(tidyverse)
require(magrittr)
require(terra)
require(sf)
require(pals)
require(showtext)
require(ggtext)
require(gghighlight)
require(ggspatial)
require(gt)
require(tidyterra)
require(ggpmisc)
require(viridis)
require(bcmaps)
require(ochRe)
```

```{r graphics-setup, include = FALSE}

pal.parl <- colorRampPalette(ochRe::ochre_palettes[["parliament"]])
pal.nam <- colorRampPalette(ochRe::ochre_palettes[["namatjira_qual"]])
font_add_google('Anton', 'anton')
showtext_auto()

```

This report provides several metrics of interest from the sampling stage of the PEM process, including comparisons of planned samples versus actual samples and various metrics on collected points. More details on the data, methodology, and results from the samplR workflow can be found in the \[PEM Manual\].

Below is a map of the sample plan for the AOI. The sample plan is generated by first developing landscape-level covariates (e.g., biogeoclimatic zones, topographic indices) at a 25m resolution to ensure environmental variability is captured. A cost layer is then created using road networks and terrain difficulty, assigning higher costs to inaccessible areas and recent disturbances. Using these inputs, Conditional Latin Hypercube Sampling (cLHS) is applied to distribute sample points efficiently while maintaining environmental representation, ensuring sites are at least 1000m apart. Paired transects are generated for each site, selecting the most cost-effective transect option based on terrain and accessibility. Finally, the selected sample plan undergoes manual review, with potential site replacements if accessibility issues arise.

```{r get-sample-plan, include = FALSE}

s1_sampling_path <- "C:/Users/ccarmour.stu/OneDrive/PEM_report_files/Boundary_AOI/transect_layout/s1_sampling.gpkg"

aoi_path <- "C:/Users/ccarmour.stu/OneDrive/PEM/PEM_report_files/PEM_report_files/Boundary_AOI/base_layers/aoi.gpkg"
roads_path <- "C:/Users/ccarmour.stu/OneDrive/PEM/PEM_report_files/PEM_report_files/Boundary_AOI/base_layers/roads_vetted.gpkg"

aoi <- sf::st_read(aoi_path)
roads <- sf::st_read(roads_path)


# Parse out layer names because we need to check that they all exist for each subzone
layers <- sf::st_layers(s1_sampling_path) %>%
  .$name %>%
  as_tibble() %>%
  rename(layer_name = value) %>%
  dplyr::mutate(szvp = purrr::map_chr(stringr::str_split(layer_name, pattern = "_"), 1),
                szvp = stringr::str_replace_all(szvp, pattern = " ", replacement = ""),
                short_layer_name = purrr::map_chr(stringr::str_split(layer_name, pattern = "_"), ~ paste(.x[-1], collapse = "_")))

# What subzones are presenting in this sample plan?
szvp_sp <- layers %>%
  pull(szvp) %>%
  unique()

# What layers exist for all subzones?
usable_layers <- layers %>%
  count(short_layer_name) %>%
  filter(n == length(szvp_sp)) %>%
  pull(short_layer_name)

# Define a "layers of interest" vector
loi <- vector()

if("transects_all_buffered" %in% usable_layers){
  loi <- layers$layer_name[str_detect(string = layers$layer_name, pattern = "transects_all_buffered$")]
}
if("transects_all" %in% usable_layers & length(loi) == 0){
  loi <- layers$layer_name[str_detect(string = layers$layer_name, pattern = "transects_all$")]
}

layers_comb <- st_read(s1_sampling_path) %>% filter(FALSE)

for(i in 1:length(loi)){
  layer <- sf::st_read(s1_sampling_path, layer = loi[i])
  if("ID" %in% names(layer)){
    layer <- rename(layer, id = ID)
  }
  layer <- dplyr::select(layer, c("id", "geom"))
  layers_comb <- rbind(layers_comb, layer)
}

layers_comb <- layers_comb %>%
  mutate(szvp = map_chr(str_split(id, pattern = "_"), 1),
         szvp = str_replace_all(szvp, pattern = " ", replacement = ""),
         szvp = as.factor(szvp),
         id = str_replace_all(id, pattern = " ", replacement = ""))

tsts <- layers_comb %>%
  sf::st_drop_geometry() %>%
  filter(str_detect(id, pattern = "cLHS")) %>%
  group_by(szvp) %>%
  summarize(cLHS_count = n()) %>%
  mutate(total_count = 2*cLHS_count)

## Add tram
layers_comb_w_labels <- left_join(layers_comb, tsts, by = "szvp") %>%
  mutate(label = stringr::str_c(szvp, " (n_cLHS = ", as.character(cLHS_count), ")"))

```

The table below summarizes how many transects were planned for each subzone/variant.

```{r tst-table, echo = FALSE}

gt(tsts) %>%
  tab_header(
    title = md("**Transects by BEC Subzone/Variant**")
  ) %>%
  cols_label(
    szvp = "",
    cLHS_count = "cLHS only",
    total_count = "cLHS + Paired"
  ) %>%
  grand_summary_rows(
    columns = c(cLHS_count, total_count),  # Numeric columns to summarize
    fns = list(
      Total = ~sum(.)
    )
  )



```

The map below shows the location of samples across the study area by subzone. The count includes only the cLHS transects, not the pairs - the actual number of planned samples is therefore double the indicated number.

```{r sample-plan-map, echo = FALSE}

#| fig-width: 8
#| fig-height: 4

ggplot2::ggplot() +
  
  tidyterra::geom_spatvector(data = terra::vect(aoi), color = "black", fill = "transparent") +
  tidyterra::geom_spatvector(data = terra::vect(roads), color = "grey", fill = "transparent") +
  tidyterra::geom_spatvector(data = terra::vect(layers_comb_w_labels), aes(color = label), size = 2) +
  labs(color = "BEC Subzone/Variant") +
  ggspatial::annotation_north_arrow(
    location = "tr", # Position: bottom-right
    which_north = "true", # True North
    pad_x = unit(0.5, "cm"), # Padding from x-axis
    pad_y = unit(0.5, "cm"), # Padding from y-axis
    style = ggspatial::north_arrow_fancy_orienteering() # Style of the arrow
  ) +
  theme(
    legend.position = "bottom"
  )
```


Often, due to constraints in the field or outdated information on roads, cutblocks, or other critical access points, not all transects are able to be sampled. We compare the transect IDs between the sampling plan and the attributed sample data.

```{r compare-tscts, include = FALSE}
## Get sample data

pts_path <- "C:/Users/ccarmour.stu/OneDrive/PEM/PEM_report_files/PEM_report_files/Boundary_AOI/trainingData/clean/s1_transect_all_pts.gpkg"

pts <- sf::st_read(pts_path)

tscts_all <- pts %>%
  sf::st_drop_geometry() %>%
  dplyr::mutate(id = transect_id,
                id = stringr::str_replace_all(id, pattern = " ", replacement = "")) %>%
  dplyr::group_by(id) %>%
  dplyr::summarize(n()) %>%
  mutate(szvp = purrr::map_chr(str_split(id, pattern = "_"), 1),
         szvp = stringr::str_replace_all(szvp, pattern = " ", replacement = ""),
         szvp = as.factor(szvp)) %>%
  dplyr::full_join(layers_comb, ., by = "id", keep = TRUE)

tscts_sampled <- tscts_all %>%
  filter(!is.na(id.y)) %>%
  mutate(szvp = case_when(is.na(szvp.x) ~ szvp.y,
                          is.na(szvp.y) ~ szvp.x,
                          TRUE ~ szvp.x)) %>%
  dplyr::select(!c(szvp.x, szvp.y))

tscts_sampled_count <- tscts_sampled %>%
  sf::st_drop_geometry() %>%
  group_by(szvp) %>%
  summarize(count = n())

tscts_sampled_w_labels <- left_join(tscts_sampled, tscts_sampled_count, by = "szvp") %>%
  mutate(label = stringr::str_c(szvp, " (n = ", as.character(count), ")"))

```

This map shows the actual transects that were sampled, with cLHS *and* paired transects included in the count.

```{r sample-data-map, echo = FALSE}

#| fig-width: 8
#| fig-height: 4

ggplot2::ggplot() +
  tidyterra::geom_spatvector(data = terra::vect(aoi), color = "black", fill = "transparent") +
  tidyterra::geom_spatvector(data = terra::vect(roads), color = "grey", fill = "transparent") +
  tidyterra::geom_spatvector(data = terra::vect(tscts_sampled_w_labels ), aes(color = label), size = 2) +
  labs(color = "BEC Subzone/Variant") +
  ggspatial::annotation_north_arrow(
    location = "tr", # Position: bottom-right
    which_north = "true", # True North
    pad_x = unit(0.5, "cm"), # Padding from x-axis
    pad_y = unit(0.5, "cm"), # Padding from y-axis
    style = ggspatial::north_arrow_fancy_orienteering() # Style of the arrow
  ) +
  theme(
    legend.position = "bottom"
  )


```

```{r points-by-ss, include = FALSE}

pts_cleaned <- pts %>%
  dplyr::select(c(mapunit1, mapunit2, transect_id)) %>%
  mutate(szvp = str_split(transect_id, pattern = "_", simplify = TRUE)[,1],
         szvp = stringr::str_replace_all(szvp, pattern = " ", replacement = ""),
         szvp = as.factor(szvp),
         ss_1 = str_split(mapunit1, pattern = "_", simplify = T)[,2],
         ss_2 = case_when(!is.na(mapunit2) ~ str_split(mapunit2, pattern = "_", simplify = T)[,2],
                          TRUE ~ NA_character_)) %>%
  filter(stringr::str_detect(mapunit1, pattern = "_"))

sz_list <- pts_cleaned %>%
  filter(!is.na(szvp)) %>%
  pull(szvp) %>%
  unique()

## Make a round up function
round_up_mag <- function(x) {
  ifelse(x == 0, 0, ceiling(x / 10^floor(log10(abs(x)))) * 10^floor(log10(abs(x))))
}


```
The figure below shows how many points from each site series were sampled across each subzone.
```{r pts-bar-graph, echo = FALSE}

for(i in 1:length(sz_list)){
  
  pts_by_sz <- pts_cleaned %>%
    filter(szvp == sz_list[i]) %>%
    group_by(ss_1) %>%
    summarize(count = n())
  
  max_pts <- max(pts_by_sz$count)
  
  x <- ggplot(pts_by_sz, aes(x = reorder(ss_1, -count), y = count)) +
    geom_bar(stat = "identity", fill = pal.nam(8)[6]) +
    labs(
      title = stringr::str_c(sz_list[i]),
      x = "Site Series Code",
      y = "Number of Classified Sample Points",
    ) +
    # scale_x_continuous(breaks = seq(0, 250, by = 10)) +
    scale_y_continuous(breaks = seq(from = 0, to = round_up_mag(max_pts), by = floor(round_up_mag(max_pts)/10))) +
    theme(
      # text = element_text(family = "anton"),
      panel.background = element_rect("transparent"),
      panel.grid.major = element_line(colour = "grey88"),
      # panel.grid.minor = element_line(colour = "grey88"),
      # axis.ticks = element_blank(),
      # axis.text = element_text(size = 24),
      # axis.ticks = element_line(size = 0.5),
      axis.title.x = element_text(size = 18, face = "bold"),
      axis.title.y = element_text(size = 18, face = "bold"),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5),
      plot.title = element_text(size = 24, hjust = 0.5),
    )
  
  print(x)
}



```

